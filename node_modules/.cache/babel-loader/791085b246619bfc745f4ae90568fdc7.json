{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar PUNCTUATION_LIST = [\".\", \",\", \"!\", \"?\", \"'\", \"{\", \"}\", \"(\", \")\", \"[\", \"]\", \"/\"];\n\nvar trimText = function trimText(text) {\n  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 80;\n  var ideal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;\n  var max = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 200; //This main function uses two pointers to move out from the ideal, to find the first instance of a punctuation mark followed by a space. If one cannot be found, it will go with the first space closest to the ideal.\n\n  if (max < min || ideal > max || ideal < min) {\n    throw new Error(\"The minimum length must be less than the maximum, and the ideal must be between the minimum and maximum.\");\n  }\n\n  if (text.length < ideal) {\n    return [text, ''];\n  }\n\n  var pointerOne = ideal;\n  var pointerTwo = ideal;\n  var firstSpace, resultIdx;\n\n  var setSpace = function setSpace(idx) {\n    if (spaceMatch(text[idx])) {\n      firstSpace = firstSpace || idx;\n    }\n  };\n\n  while (pointerOne < max || pointerTwo > min) {\n    if (checkMatch(pointerOne, text, max, min)) {\n      resultIdx = pointerOne + 1;\n      break;\n    } else if (checkMatch(pointerTwo, text, max, min)) {\n      resultIdx = pointerTwo + 1;\n      break;\n    } else {\n      setSpace(pointerOne);\n      setSpace(pointerTwo);\n    }\n\n    pointerOne++;\n    pointerTwo--;\n  }\n\n  if (resultIdx === undefined) {\n    if (firstSpace && firstSpace >= min && firstSpace <= max) {\n      resultIdx = firstSpace;\n    } else if (ideal - min < max - ideal) {\n      resultIdx = min;\n    } else {\n      resultIdx = max;\n    }\n  }\n\n  return [text.slice(0, resultIdx), text.slice(resultIdx).trim()];\n};\n\nvar spaceMatch = function spaceMatch(character) {\n  if (character === \" \") {\n    return true;\n  }\n};\n\nvar punctuationMatch = function punctuationMatch(idx, text) {\n  var punctuationIdx = PUNCTUATION_LIST.indexOf(text[idx]);\n\n  if (punctuationIdx >= 0 && spaceMatch(text[idx + 1])) {\n    return true;\n  }\n};\n\nvar checkMatch = function checkMatch(idx, text, max, min) {\n  if (idx < max && idx > min && punctuationMatch(idx, text)) {\n    return true;\n  }\n};\n\nvar _default = trimText;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["C:/Users/prana/code-market-frontend/node_modules/read-more-react/dist/utils/trimText.js"],"names":["Object","defineProperty","exports","value","PUNCTUATION_LIST","trimText","text","min","arguments","length","undefined","ideal","max","Error","pointerOne","pointerTwo","firstSpace","resultIdx","setSpace","idx","spaceMatch","checkMatch","slice","trim","character","punctuationMatch","punctuationIdx","indexOf","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar PUNCTUATION_LIST = [\".\", \",\", \"!\", \"?\", \"'\", \"{\", \"}\", \"(\", \")\", \"[\", \"]\", \"/\"];\n\nvar trimText = function trimText(text) {\n  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 80;\n  var ideal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;\n  var max = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 200;\n\n  //This main function uses two pointers to move out from the ideal, to find the first instance of a punctuation mark followed by a space. If one cannot be found, it will go with the first space closest to the ideal.\n  if (max < min || ideal > max || ideal < min) {\n    throw new Error(\"The minimum length must be less than the maximum, and the ideal must be between the minimum and maximum.\");\n  }\n\n  if (text.length < ideal) {\n    return [text, ''];\n  }\n\n  var pointerOne = ideal;\n  var pointerTwo = ideal;\n  var firstSpace, resultIdx;\n\n  var setSpace = function setSpace(idx) {\n    if (spaceMatch(text[idx])) {\n      firstSpace = firstSpace || idx;\n    }\n  };\n\n  while (pointerOne < max || pointerTwo > min) {\n    if (checkMatch(pointerOne, text, max, min)) {\n      resultIdx = pointerOne + 1;\n      break;\n    } else if (checkMatch(pointerTwo, text, max, min)) {\n      resultIdx = pointerTwo + 1;\n      break;\n    } else {\n      setSpace(pointerOne);\n      setSpace(pointerTwo);\n    }\n\n    pointerOne++;\n    pointerTwo--;\n  }\n\n  if (resultIdx === undefined) {\n    if (firstSpace && firstSpace >= min && firstSpace <= max) {\n      resultIdx = firstSpace;\n    } else if (ideal - min < max - ideal) {\n      resultIdx = min;\n    } else {\n      resultIdx = max;\n    }\n  }\n\n  return [text.slice(0, resultIdx), text.slice(resultIdx).trim()];\n};\n\nvar spaceMatch = function spaceMatch(character) {\n  if (character === \" \") {\n    return true;\n  }\n};\n\nvar punctuationMatch = function punctuationMatch(idx, text) {\n  var punctuationIdx = PUNCTUATION_LIST.indexOf(text[idx]);\n\n  if (punctuationIdx >= 0 && spaceMatch(text[idx + 1])) {\n    return true;\n  }\n};\n\nvar checkMatch = function checkMatch(idx, text, max, min) {\n  if (idx < max && idx > min && punctuationMatch(idx, text)) {\n    return true;\n  }\n};\n\nvar _default = trimText;\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}